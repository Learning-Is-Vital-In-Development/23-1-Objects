## 01 협력과 메시지

**클라이언트- 서버 모델**

    **클라이언트**: 협력 안에서 메시지를 전송하는 객체

    **서버**: 메시지를 수신하는 객체

- 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용
    - 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성
    1. 객체가 수신하는 메시지의 집합
    2. 외부의 객체에게 전송하는 메시지의 집합

> 협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직하다.
> 
- 용어 정리
    - `메시지`
        - 객체가 다른 객체와 협력하기 위해 사용하는 의사소통 메커니즘. 일반적으로 객체의 오퍼레이션이 실행되도록 요청하는 것을 **메시지 전송**이라고 부른다.
        - 클라이언트-서버 모델 관점에서 메시지 전송자는 **클라이언트**, 메시지 수신자는 **서버**라고 부르기도 한다.
        - 메시지는 오퍼레이션명(operation name)과 인자(argument)로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것
    - `오퍼레이션`
        - 객체가 다른 객체에게 제공하는 추상적인 서비스다. 메시지가 전송자와 수신자 사이의 협력 관계를 강조하는 데 비해 **오퍼레이션은 메시지를 수신하는 객체의 인터페이스를 강조**
        - **메시지 수신**이란 메시지에 대응되는 객체의 오퍼레이션을 호출하는 것을 의미
    - `메서드`
        - 메시지에 응답하기 위해 실행되는 코드 블록
        - 메서드는 오퍼레이션의 구현이므로 동일한 오퍼레이션이라고 해도 메서드는 다를 수 있다.
        - **코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다는 것**
    - `퍼블릭 인터페이스`
        - 객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메시지의 묶음
        - 클래스의 퍼블릭 메서드들의 집합이나 메시지의 집합을 가리키는 데 사용
    - `시그니처`
        - 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합한 것
        - 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것
            
            메서드는 이 시그니처에 구현을 더한 것
            

---

## 02 인터페이스와 설계 품질

- 좋은 인터페이스는 **최소한의 인터페이스**와 **추상적인 인터페이스**라는 조건을 만족해야 한다.
    
     - 책임 주도 설계 방법: 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지한다. 
    
- 용어 정리
    - `디미터 법칙`
        - 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것
        - 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍해야 한다.
        - **부끄럼타는 코드(shy code)** : 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드
        - **기차 충돌(train wreck)**: 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태로, 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다.
        
        > 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수도 있다.
        > 
        
    - `묻지 말고 시켜라`
        - 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다.
        - 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스 향상 가능
        
        > 단순하게 객체에게 묻지 않고 시킨다고 해서 모든 문제가 해결되는 것은 아니다. 인터페이스는 객체가 어떻게 하는지가 아니라 **무엇을 하는지**를 서술해야한다.
        > 
    
    - `의도를 드러내는 인터페이스`
        - **의도를 드러내는 선택자**: 메서드가 **무엇**을 하는지가 드러나게 이름 짓는 패턴
        - **의도를 드러내는 인터페이스**: 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는 것
        - 객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다.
        - 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 된다.
        
        > 객체에게 묻지 말고 시키되 구현 방법이 아닌 클라이언트의 의도를 드러내야 한다.
        > 
    - 정리
    - **디미터 법칙**: 객체 간의 협력을 설계할 때 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록 제한한다.
    - **묻지 말고 시켜라 원칙**: 디미터 법칙을 준수하는 협력을 만들기 위한 스타일을 제시한다.
    - **의도를 드러내는 인터페이스 원칙**: 객체의 퍼블릭 인터페이스에 어떤 이름이 드러나야 하는지에 대한 지침을 제공함으로써 코드의 목적을 명확하게 커뮤니케이션할 수 있게 해준다.

---

## 03 원칙의 함정

- **디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.**
    - 기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.
- 결합도와 응집도의 충돌
    - 위임 메서드를 통해 객체의 내부 구조를 감추는 것은 협력에 참여하는 객체들의 결합도를 낮출 수 있는 동시에 객체의 응집도를 높일 수 있는 가장 효과적인 방법이다.
    - 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋지만 자료구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.
    
    > 그러나 디미터 법칙과 묻지 말고 시켜라 원칙을 무작정 따르면 애플리케이션은 응집도가 낮은 객체로 넘쳐날 것이다.
    > 

---

## 04 명령-쿼리 분리 원칙

- 용어 정리
    - `루틴` : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
    - `프로시저`: 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류
    - `함수`: 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류
    - 제약
        - **프로시저**는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
        - **함수**는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
    - `명령`: 객체의 상태를 수정하는 오퍼레이션 (프로시저)
    - `쿼리`: 객체와 관련된 정보를 반환하는 오퍼레이션 (함수)
    - 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다.
    
    > 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다.
    > 
    - 규칙
        - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
        - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

---

- `참조 투명성` : “어떤 표현식  e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성”
    - **참조 투명성**이라는 특성을 잘 활용하면 버그가 적고, 디버깅이 용이하며, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있다.
    - 장점
        - 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
        - 모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.
    - 명령-쿼리 분리 원칙은 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있게 된다.

---

`명령-쿼리 분리 원칙`

- 객체가 단순히 어떤 일을 해야 하는지뿐만 아니라 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다.
- 따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 된다.

<aside>
💡 책임 주도 설계 원칙을 따라 **메시지가 객체를 결정하게 하라.**

</aside>
