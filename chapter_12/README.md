**상속을 사용하려는 목적?**

- 단순히 코드를 재사용 하기 위해서.
- 클라이언트 관점에서 인스턴스를 동일하게 행동하는 그룹으로 묶기 위해서.

**단순히 코드를 재사용 하기 위해서 상속을 사용하지 말아야 한다.**

초기에 객체지향 패러다임이 주목받았을 때

**상속** 은 **타입 계층**과 **다형성**을 구현할 수 있는 거의 유일한 방법이었다.

현재는 다형성을 구현할 수 있는 다양한 방법들을 제공하고 있다. 

**상속에 관점**에서 **다형성**이 구현되는 기술적인 메커니즘을 보자.

1. 다형성이 런타임에 메시지를 처리하기에 적합한 메서드를 동적으로 탐색하는 과정을 통해 구현된다.
2. 상속이 이런 메서드를 찾기 위한 일종의 탐색 경로를 클래스 계층의 형태로 구현하기 위한 방법이다.

## 다형성

- 하나의 추상 인터페이스에 대해 코드를 작성하고, 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력

**다형성 분류**

![KakaoTalk_20230222_013335494.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d322cc75-f4a8-421b-bb3a-24a0cc73a2d9/KakaoTalk_20230222_013335494.jpg)

### **오버로딩 다형성**

```java
public class Money{
	public Money plus(Money amount) { ... }
  public Money plus(BigDecimal amount) { ... }
  public Money plus(long amount) { ... }
}
```

: 클래스 안에 동일한 이름의 메서드가 존재하는 경우

### 강제 다형성

: 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식을 가리킴 

ex) 

1 + 3 → 정수형

“String” + “name” → 문자열 타입

- 일반적으로 오버로딩 다형성과 강제 다형성을 같이 사용하면 어떤 메서드가 호출될지 판단하기 어려워짐

### 매개변수 다형성

- 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식

ex) List 인터페이스

### 포함 다형성

: 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력을 의미

- **서브타입 다형성**
    - 일반적인 다형성임

포함 다형성을 위한 전제조건은 **자식 클래스**가 **부모 클래스**의 **서브타입**이어야 된다.

→ 상속의 목적은 

코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축하는 것.

포함 다형성을 위해 상속을 사용하는 가장 큰 이유

: 상속이 클래스들을 계층으로 쌓아 올린 후 상황에 따른 적절한 메서드를 선택할 수 있는 메커니즘을 제공하기 때문.

객체지향 패러다임 아이디어

- 데이터
- 행동 (객체)

- 데이터 관점의 상속
    - 부모클래스에 정의한 모든 데이터가 자식 클래스 인스턴스의 자동으로 포함
- 행동 관점의 상속
    - 부모클래스에 정의한 일부 메서드가 자동으로 자식 클래스에 포함
    

타입 계층의 고민 없이 재사용하기 위해 사용할 경우 

→ 이해하기 어렵고 유지보수 하기 버거운 코드가 만들어짐

## 데이터 관점의 상속

![KakaoTalk_20230222_021455658.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/206270eb-e81f-4410-8373-c3ad64fe0701/KakaoTalk_20230222_021455658.jpg)

![KakaoTalk_20230222_021455658_01.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ea030074-34e6-4380-9111-f153b37460ec/KakaoTalk_20230222_021455658_01.jpg)

## 행동 관점의 상속

: 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것

부모클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 인터페이스에 합쳐진다고 표현했지만,

실제로 합쳐지거나 복사하는 작업이 수행되는 것은 아니다.

→ 런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색하기 때문이다.

행동 관점 → 상속 관계로 연결된 클래스 사이의 메서드 탐색 과정을 이해하는 것

## 업캐스팅과 동적 바인딩

### 업캐스팅

: 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다.

### 동적 바인딩

: 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정하기 때문에 가능하다. 

객체지향 언어에서 메서드를 실행하는 방법은 **메시지를 전송**하는 것.

함수를 호출하는 언어들은 호출될 함수를 **컴파일타임**에 결정함

- 정적 바인딩 (static binding)
- 초기 바인딩 (early binding)
- 컴파일타임 바인딩 (compile-time binding)

이라고 불림

객체지향 언어에서 메시지를 수신 했을 때 실행될 메서드가 **런타임에 결정됨**

- 동적 바인딩
- 지연 바인딩

이라고 불림

객체 지향이 제공하는 업캐스팅과 동적 바인딩을 이용하면

부모클래스 참조에 대한 메시지 전송을 

자식클래스에 대한 메서드 호출로 변환할 수 있다.

어떤 규칙에 따라 **메서드 전송**과 **메서드 호출**을 바인딩 하는 것일까?

## 동적 메서드 탐색

- 메서드를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검ㅁ사한다.
    
    존재하면 메서드를 실행하고 탐색을 종료한다.
    
- 메서드를 찾기 못했다면 부모 클래스에서 메서드 탐색을 계속한다. 이 과정은 적합한 메서드를 찾을 때까지 상속 계층 따라 올라가며 계속된다.

- 상속 계층의 가장 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단한다.

### self 참조

객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 

메시지를 수신한 객체를 가리키도록 설정한다.

### 메서드 탐색

자식클래스에서 부모 클래스 방향으로 진행된다.

항상 자식 클래스의 메서드가 부모 클래스의 메서드보다 먼저 탐색 → 더 높은 우선순위를 가짐

동적 메서드 탐색의 원리

1. 자동적인 메시지 위임
    - 처리할 수 없으면 부모 클래스에게 처릴르 위임 → 자동으로 이뤄짐
2. 동적인 문맥
    - 컴파일 시점이 아닌 실행 시점에 이뤄지며, 메서드를 참색하는 경로는 self 참조를 이용해서 결정한다.

메시지가 처리되는 문맥을 이해하기 위해서는 정적인 코드만 보는것으로 충분하지 않음.

self 참조를 통해 문맥을 동적으로 결정

- 메서드 오버로딩
    - 자식이 먼저 탐색되기에 발생
- 메서드 오버라이딩
    - 시그니처가 동일하지 않을 경우, 상속 계층에 걸쳐 사이좋게 공존

 - c++ 에서는 상속 계층 사이에 오버로딩을 금지함 → **이름 숨기기** 라고 불림

## 동적인 문맥

self 전송은 자식 클래스에서 부모 클래스 방향으로 진행되는 동적 메서드 탐색 경로를 다시 self 참조가 가리키는 원래의 자식 클래스로 이동시킨다.

self 전송이 깊은 상속 계층과 중간에 메서드 오버라이딩과 만나면 극단적으로 어려운 코드가 만들어짐

자신이 처리할 수 없는 메시지를 부모 클래스로 처리를 위임하는데,

그래도 이해를 못하면 (객체가 이해를 못하면)?

- 정적 타입 언어 → 컴파일 에러 발생, 안정적
- 동적 타입 언어
    - 컴파일 단계가 존재하지 않기에 코드를 실행해보기 전까지 알 수 없음 → self 참조가 탐색함
    - doseNotUnderstand 나 method_missing 예외 발생
    - 또는 정의되지 않은 메시지를 처리도 가능
    

### self 대 super

self 참조의 가장 큰 특징은 동적

자식 클래스에서 부모클래스의 구현을 재사용하는 경우

→ super 참조라는 내부 변수 이용

super

부모 클래스에 정의된 메서드를 실행하기 위한 것이 아님

“지금 이 클래스의 부모 클래스에서 부터 메서드 탐색을 시작하세요”

**위임**

자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청

**프로토타입 기반의 객체지향 언어**

객체 사이의 자동적인 메시지 위임을 통해 상속을 구현

중요한 것은 클래스 기반의 상속과 객체기반의 위임 사이에 기본 개념과 멧커니즘을 공유한다는 사실