# 부록 A 계약에 의한 설계

인터페이스만으로 객체의 행동에 관한 다양한 관점을 전달하기 어렵다.
명령의 부수효과를 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단이 **계약에 의한 설계**이다.

---

## 01 협력과 계약

메시지의 이름과 파라미터 목록은 시그니처를 통해 전달할 수 있지만 

협력을 위해 필요한 약속과 제약은 인터페이스를 통해 전달할 수 없기 때문에 협력과 관련된 상당한 내용이 암시적인 상태로 남게 된다. 

- if 문을 사용한 일반적인 파라미터 체크 방식과 다른 점은?
    - **문서화**
        - 계약에 의한 설계 라이브러리 Code Contracts 사용하면 제약 조건을 명시적으로 표현하는 것 가능
        - 제약 조건을 자동으로 문서화 가능 / 실행을 통해 검증 가능

## 02 계약에 의한 설계

계약

- 협력에 참여하는 각 객체는 계약으로부터 **이익**을 기대하고 이익을 얻기 위해 **의무**를 이행한다.
- 협력에 참여하는 각 객체의 이익과 의무는 객체의 인터페이스 상에 **문서화**된다.

의도를 드러내는 인터페이스를 만들어서 협력을 위해 수행해야 하는 제약조건을 명시할 수 있다.

- 계약에 의한 설계를 구성하는 세 가지 요소
    - 사전조건 (precondition)
        - 메서드가 호출되기 위해 만족돼야 하는 조건
        - 메서드의 요구사항 명시
        - 메서드를 실행하는 클라이언트의 의무
    - 사후조건 (postcondition)
        - 메서드가 실행된 후에 클라이언트에게 보장해야 하는 조건
        - 서버의 의무
    - 불변식 (invariant)
        - 항상 참이라고 보장되는 서버의 조건
        
    
    **사후조건**
    
    - 인스턴스 변수의 상태가 올바른지를 서술하기 위해
    - 메서드에 전달된 파라미터의 값이 올바르게 변경됐는지를 서술하기 위해
    - 반환값이 올바른지를 서술하기 위해

사전조건보다 사후조건을 정의하는 것이 더 어려울 수 있다

- 한 메서드 안에서 return 문이 여러 번 나올 경우
    
    : 모든 return 문마다 결괏값이 올바른지 검증하는 코드를 추가해야 함
    

- 실행 전과 실행 후의 값을 비교해야 하는 경우
    
    : 실행 전의 값이 메서드 실행으로 인해 다른 값으로 변경됐을 수 있기 때문에 두 값이 비교하기 어려울 수 있음
    

사후조건을 정의하기 위해 제공되는 **Contract.Ensures 메서드** 사용

**불변식**

- 인스턴스 생명주기 전반에 걸쳐 지켜져야 하는 규칙을 명세
- 특성
    - 불변식은 클래스의 모든 인스턴스가 생성된 후에 만족돼야 한다.
    - 불변식은 클라이언트에 의해 호출 가능한 모든 메서드에 의해 준수돼야 한다.
- 불변식은 메서드가 실행되기 전에 사전조건과 함께 실행되며, 메서드가 실행된 후에 사후조건도 함께 실행된다.

**Contract.Invariant 메서드**를 이용해 불변식 정의

## 03 계약에 의한 설계와 서브타이핑

서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다. 

**리스코프 치환 원칙의 세분화된 두 종류의 규칙**

1. 협력에 참여하는 객체에 대한 기대를 표현하는 **계약규칙** : 슈퍼타입과 서브타입 사이의 사전조건, 사후조건 불변식에 대한 제약 규칙

- 서브타입에 더 강력한 사전조건을 정의할 수 없다.
- 서브타입에 더 완화된 사후조건을 정의할 수 없다.
- 슈퍼타입의 불변식을 서브타입에서도 반드시 유지돼야 한다.

2. 교체 가능한 타입과 관련된 **가변성 규칙 :** 파라미터와 리턴타입의 변형과 관련된 규칙

- 서브타입의 메서드 파라미터는 반공변성을 가져야 한다.
- 서브타입의 리턴타입은 공변성을 가져야 한다.
- 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안 된다

**서브타입에 더 강력한 사전조건을 정의할 수 없다.**

서브타입이 슈퍼타입에 정의된 사전조건을 강화하면 기존에 체결된 계약을 위반하게 된다. 슈퍼타입을 대체할 수 없음.

- 사전조건을 완화시켜서 null 인자를 전달해도 예외가 발생하지 않게 수정. 리스코프 치환원칙을 위반하지 않음.

**서브타입에 더 완화된 사후조건을 정의할 수 없다.**

- 반대로 사후조건을 강화하는 방법은 계약에 아무 문제가 없다.

**슈퍼타입의 불변식을 서브타입에서도 반드시 유지돼야 한다.**

자식 클래스가 계약을 위반할 수 있는 코드를 작성하는 것을 막을 수 있는 유일한 방법

→ 인스턴스 변수의 가시성을 **protected**가 아니라 **private**으로 만드는 것 뿐.

[**가변성 규칙]**

**서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안 된다.**

- 일반적으로 부모클래스가 던지는 예외가 속한 상속계층이 아닌 다른 상속 계층에 속하는 예외를 던질 경우 자식 클래스는 부모클래스를 대체할 수 없다. 따라서 서브타입이 아님.

**서브타입의 리턴타입은 공변성을 가져야 한다.**

프로그램의 어떤 위치에서 두 타입 사이의 치환가능성

- 공변성 covariance : S와 T 사이의 서브타입 관계가 그대로 유지. 이 경우 해당 위치에서 서브타입인 S가 슈퍼타입인 T 대신 사용될 수 있다.

- 반공변성 contravariance : S와 T 사이의 서브타입 관계가 역전된다. 이 경우 해당 위치에서 슈퍼타입 T가 서브타입 S 대신 사용될 수 있다.

- 무공변성 invariance : S와 T 사이에 아무 관계가 존재하지 않음. 둘중 어느 하나도 하나를 대신 사용 불가.

슈퍼타입 대신 서브타입을 반환하는 것은 더 강력한 사후조건을 정의하는것과 같다

**리턴타입 공변성 return type covariance** - 메서드를 구현한 클래스의 타입계층 방향과 리턴타입의 타입 계층 방향이 동일한 경우

**서브타입의 메서드 파라미터는 반공변성을 가져야 한다.**

- **파라미터 반공변성은 지원하는 언어는 없으나 제네릭 프로그래밍에서 중요한 의미를 가짐.**

사전조건은 파라미터에 대한 제약조건.

좀 더 완화된 슈퍼타입을 파라미터로 받을 수 있는것.

리턴타입은 사후조건과 관련이 있는것.

슈퍼타입에 정의된 사후조건을 강화할 수 있음. 더 강화된 서브타입 인스턴스 반환.

진정한 **서브타이핑 관계**를 만들기 위해서…

<aside>
💡 서브타입에 더 강력한 사전조건이나 더 완화된 사후조건을 정의해서는 안 되며 슈퍼타입의 불변식을 유지하기 위해 항상 노력해야 한다. 또한 서브타입에서 슈퍼타입에서 정의하지 않은 예외를 던져서는 안된다.

</aside>
