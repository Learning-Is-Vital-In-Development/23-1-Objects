# Chapter 15 - 디자인 패턴과 프레임워크

## 디자인 패턴 vs 프레임워크

### 디자인 패턴

설계를 재사용하기 위한 것

소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법

특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공함

→ **일관성 있는 협력을 만들기 위해 재사용할 수 있는 설계의 묶음**

### 프레임워크

설계와 코드를 **함께 재사용**하기 위한 것

애플리케이션 아키텍처를 구현 코드의 형태로 제공함

특정한 변경을 일관성 있게 다룰 수 있는 코드 템플릿을 제공함

→ **일관성 있는 협력을 제공하는 확장 가능한 코드**

⇒ 둘 다 협력을 일관성 있게 만들 수 있는 방법

> *애플리케이션 아키텍처: 소프트웨어 애플리케이션을 설계하고 구현하는 방식. 소프트웨어의 기능, 성능, 유지 보수성 등을 결정하며 이러한 요소들이 서로 어떻게 상호작용하고 연결되는지를 결정함*
> 

### 소프트웨어 패턴

패턴이란?

→ 하나의 실무 컨텍스트에서 유용하게 사용해 왔고 다른 실무 컨텍스트에도 유용할 것이라고 예상되는 아이디어

→ 실제 프로젝트의 실무 경험에서 비롯됨 : 경험의 산물

→ 실무 경험이 적은 초보자라고 해도 패턴을 익히고 반복적으로 적용하며 유연하고 품질 높은 소프트웨어 개발 방법을 익힐 수 있음

→ 수준 높은 대화 가능 (ex: 장황한 대화 대신 ‘STRATEGY 패턴’)

→ 홀로 존재하지 않음

3의 규칙

→ 세 가지의 서로 다른 시스템에 특별한 문제 없이 적용할 수 있고 유용한 경우에만 패턴으로 간주할 수 있음

패턴 언어(Pattern Language)

→ 연관된 패턴들의 집합이 모여 하나의 패턴 언어를 구성함

→ 패턴 시스템(Pattern System)과 동일한 의미

### 패턴 분류

패턴의 범위나 적용 단계에 따라 아키텍처 패턴(Architecture Pattern), 분석 패턴(Analysis Pattern), 디자인 패턴(Design Pattern), 이디엄(Idiom)으로 나눌 수 있음

- 디자인 패턴

일반적인 설계 문제 해결, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술

중간 규모의 패턴, 특정 설계 문제 해결이 목적, 프로그래밍 언어나 패러다임에 독립적임

- 아키텍처 패턴

디자인 패턴의 상위에 존재, 소프트웨어의 전체적인 구조를 결정하기 위해 사용 가능

미리 정의된 서브시스템 제공, 각 서스시스템의 책임을 정의, 관계를 조직화하는 규칙 포함

- 이디엄

디자인 패턴의 하위에 존재, 언어에 종속적인 하위 레벨 패턴으로 특정 언어의 이디엄이 다른 언어에서 무용지물이 될 수 있음(C언어의 COUNT POINTER)

- 분석 패턴

업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합

도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춤

### 패턴과 책임-주도 설계

- **STRATEGY** Pattern

다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공함

- **BRIDGE** Pattern

추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 만듦

- **OBSERVER** Pattern

유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공함

- **COMPOSITE** Pattern

클라이언트가 개별 객체와 복합 객체를 동일하게 취급할 수 있음

- **TEMPLATE METHOD** Pattern

알고리즘을 캡슐화하기 위해 합성 관계가 아닌 상속 관계를 사용하는 패턴

STRATEGY 패턴처럼 런타임에 알고리즘을 변경하는 것은 불가능함

- **DECORATOR** Pattern

객체의 행동을 동적으로 추가할 수 있게 하는 패턴, 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용함

→ 중요한 것은 패턴을 따르면 특정 상황에 적용 가능한 설계를 쉽고 빠르게 떠올릴 수 있다는 사실

→ 어떤 구현 코드가 어떠한 디자인 패턴을 따른다고 이야기할 때는 역할, 책임, 협력의 관점에서 유사성을 공유한다는 것이지 특정한 구현 방식을 강제하는 것은 아니다

→ 디자인 패턴에서 중요한 것은 패턴의 구현 방법이나 구조가 아니라, **어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것**임

### 패턴은 출발점이다!

패턴이 설계의 목표가 되어서는 안 됨. 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 수정할 수 있어야 함

패턴 만능주의

→ 패턴을 적용하는 컨텍스트의 적절성은 무시한 채 패턴의 구조에만 초점을 맞추는 것(망치를 들면 모든 것이 못으로 보인다)

**패턴은 복잡성의 가치가 단순성을 넘어설 때만 정당화되어야 함**

### 코드 재사용 vs 설계 재사용

디자인 패턴은 프로그래밍 언어에 독립적으로 재사용 가능한 설계 아이디어 제공을 목적으로 함

언어에 종속적인 구현 코드 정의 X, 디자인 패턴 적용을 위해서는 설계 아이디어를 프로그래밍 언어의 특성에 맞춰 가공해야 하고 구현 코드를 매번 재작성해야 함

설계 재사용 < 코드 재사용 ⇒ 컴포넌트 기반의 재사용 방법이 적용 과정에서 현실적이지 않게 됨

설계 재사용과 코드 재사용을 적절히 조합하는 것 ⇒ 가장 이상적임 ⇒ 프레임워크!

- 구조적인 측면에서의 프레임워크란:

추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계

- 사용 목적 측면에서의 프레임워크란:

애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격

### 상위 정책과 하위 정책으로 프레임워크 분리하기

변하는 것과 변하지 않는 것으로 분리 (ex: 핸드폰 과금 시스템):

변하지 않는 높은 상위 정책에 속하는 역할들의 협력 구조와, 변하는 것인 구체적인 세부 사항을  별도의 패키지로 나누기 → 별도의 ‘배포 단위’로 분리

→ 의존성 역전 원칙에 맞게, 상위 정책과 세부 사항 모두 추상화에 의존할 수 있음

상위 정책을 구현하는 패키지가 충분히 안정적이고 성숙하다면 하위 정책 패키지와 완벽히 분리해서 별도의 배포 단위로 만들 수 있음 → 재사용 가능한 요금 계산 로직을 구현한 프레임워크가 만들어진 것

### 제어 역전 원리(Inversion of Control, Hollywood)

상위 정책 재사용 → 도메인에 존재하는 핵심 개념들 사이의 협력 관계를 재사용한다는 것

의존성 역전 원리에 따라 구축되지 않은 시스템은 협력 흐름을 재사용할 수 없으며 변경에 유연하게 대처하지도 못함

**훅(hook)**

 : 프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워두는데, 이렇게 완성되지 않은 채로 남겨진 동작을 훅이라고 부름

→ 협력을 제어하는 것은 프레임워크!
