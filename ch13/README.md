
# 13. 서브클래싱과 서브타이핑

상속의 첫 번째 용도는 타입 계층을 구현하는 것이다. 타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고, 자식 클래스는 특별한 개념을 구현한다.

상속의 두 번째 용도는 코드 재사용이다. 상속을 선언만 하면 부모 클래스의 코드를 재사용할 수 있다.

상속을 사용하는 목표로 코드 재사용이 되면 안 된다. 오직 타입 계층을 구현하는 목적으로 상속을 사용해야 한다.

객체기반 프로그래밍은 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식이다.

객체지향 프로그래밍은 객체기반 프로그래밍의 한 종류로, 객체를 조합해서 애플리케이션을 개발하지만 상속과 다형성을 지원한다는 점에서 객체기반 프로그래밍과 차별화된다.

### 타입

---

- **개념 관점에서 타입**

개념 관점에서 타입이란 우리가 인지하는 세상의 사물의 종류를 의미한다.

타입은 사물을 분류하기 위한 틀로 사용된다.

어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스라고 부른다.

타입은 심볼, 내연, 외연의 세 가지 요소로 구성된다.

심볼: 타입에 이름을 붙인 것

내연: 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동(타입에 속하는 객체들이 공유하는 속성과 행동의 집합)

외연: 타입에 속하는 객체들의 집합

- **프로그래밍 언어 관점의 타입**

프로그래밍 언어 관점에서 타입은 연속적인 비트에 의미와 제약을 부여하기 위해 사용된다.

프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용된다.

1. 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.
2. 타입에 수행되는 오퍼레이션에 대해 미리 약속한 문맥을 제공한다.

위 목적을 통해 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 정확하게 전달하고 개발자들의 실수를 방지하기 위해 사용된다.

- **객체지향 패러다임 관점의 타입**

개념 관점에서의 타입과 프로그래밍 언어 관점의 타입을 조합하면 객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의하는 것이다. 다시 말하자면 다음과 같다.

객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.

(객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 한다. 객체의 타입을 결정하는 것은 내부의 속성이 아니라 외부에 제공하는 행동이다)

### 타입 계층

---

타입은 객체들의 집합이기에 다른 타입을 포함하는 것이 가능하다. 타입 안에 포함된 객체들은 좀 더 상세한 기준으로 묶어 새로운 타입을 정의하면 이 새로운 타입은 자연스럽게 기존 타입의 부분집합이 된다.(그림 13.2)

타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 슈퍼타입이라 부르고 더 특수한 타입을 서브타입이라 부른다. 내연과 외연의 관점에서 서브타입과 슈퍼타입은 다음과 같이 정의할 수 있다.

슈퍼타입

- 집합이 다른 집합의 모든 맴버를 포함한다.
- 타입 정의가 다른 타입보다 좀 더 일반적이다.

서브타입

- 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
- 타입 정의가 다른 타입보다 좀 더 구체적이다.

이를 객체지향 프로그래밍 관점에서 타입이 일반적이거나 특수하다는 뜻은 **퍼블릭 인터페이스가 일반적이거나 특수하다**는 뜻이다. 

슈퍼타입이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것이다.

서브타입이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것이다.

여기서 중요한 개념은 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다는 것이다.

### 서브클래싱과 서브타이핑

---

객체지향 프로그래밍 언어에서 타입을 구현하는 방법은 클래스를 이용하는 것이고, 타입 계층을 구현하는 방법은 상속을 이용하는 것이다. 여기서 타입 계층을 구현할 때 지켜야 하는 제약사항을 클래스와 상속의 관점에서 보면 다음과 같다.

- 언제 상속을 사용해야 하는가?
1. 상속 관계가 is-a 관계를 모델링하는가?
    
    애플리케이션을 구성하는 어휘에 대한 우리의 관점에 기반한다. 일반적으로 “자식 클래스는 부모 클래스다”라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.
    
2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
    
    상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다.(이를 부모 클래스와 자식 클래스 사이의 행동 호환성이라 한다)
    

설계 관점에서 상속을 적용할지 여부를 결정하기 위해 첫 번째 질문보다 두 번째 질문에 초점을 맞추는 것이 중요하다.

만약 두 클래스를 어휘적으로 is-a 관계를 모델링할 경우에 상속을 사용한다면 책에서 나온 예시처럼 우리의 직관에 벗어나는 상황이 발생한다.

결국 이를 해결하려면 두 타입 사이에 **행동이 호환될 경우**에만 타입 계층으로 묶어야 한다. 예시의 새와 팽귄은 새의 일반적인 특성인 날다의 행동에 팽귄이 부합하지 않기에 타입 계층으로 묶을 수 없다. (책의 445~447p는 행동 호환성을 만족시키지 않는 상속 계층을 그대로 유지한 채 클라이언트의 기대를 충족할 수 없는 이유에 대해 나온다)

여기서 중요한 것은 행동의 호환 여부를 판단하는 기준은 `클라이언트의 관점`이라는 것이다.

클라이언트의 기대에 따라 계층을 분리한다면 행동에 따라 상속 계층을 분리하기에 억지로 예외 상황을 처리하려는 이전 상황에서 벗어날 수 있다.

책의 예시에선 새를 날 수 있는 새와 날 수 없는 새 두 부류로 나누어, 팽귄을 날 수 없는 새에 속한다는 사실을 분명하게 표현했다. 이를 구현하는 측면으로 본다면 클라이언트의 기대에 따라 상속 계층을 분리하는 방법과 인터페이스를 분리하는 방법이 존재한다.(개인적인 생각으로 인터페이스를 분리하여 행동을 구현하는 측면이 재사용성에서 좋아보인다. 그림 13.5, 13.6)

이처럼 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 **인터페이스 분리 원칙**(ISP)이라고 부른다.

정리하면 타입 계층을 구현할 땐 is-a 관계로 현실 세계의 직관대로 설계하는 것이 아닌, 클라이언트의 기대에 따라 인터페이스를 분리하여 설계하는 것이 중요하다. 

**서브클래싱**: 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우(구현 상속 또는 클래스 상속이라고도 부른다)

**서브타이핑**: 타입 계층을 구성하기 위해 상속을 사용하는 경우(인터페이스 상속이라고도 부른다)

### 리스코프 치환 원칙(LSP)

---

리스코프 치환 원칙은 서브타입은 그것의 기반 타입(자기가 상속한 타입들)에 대체 가능해야 한다는 것으로 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.

Stack과 Vecter는 리스코프 치환 원칙을 위반한 전형적인 예이다. 클라이언트가 부모 클래스인 Vector에 대해 기대하는 행동을 Stack에 대해서는 기대할 수 없기 때문에 행동 호환성을 만족시키지 않기 때문이다.

직사각형을 상속한 정사각형 클래스도 우리의 직관에서는 당연하게 느껴질 수 있으나 이 상속 관계는 리스코프 치환 원칙을 위배하는 고전적인 사례이다. 

Rectangle을 사용하는 클라이언트는 도형의 높이가 다를 수 있다는 가정하에 코드를 개발한지만, Square는  Rectangle에 대해 세워진 가정을 위반할 확률이 높기에 예상한 대로 작동하지 않을 것이다. 

예를 들면 resize 메서드의 관점에서 Rectangle 대신 Square를 사용하면 resize가 가정한 높이와 폭이 다를 수 있다는 전제조건을 만족하지 않기에 메서드 실행이 실패한다. 

결국 클라이언트 관점에서 is-a 관계일 경우일 때만 참이 된다. 클라이언트 입장에서 직사각형과 정사각형을 동일하게 취급할 경우 이 둘은 참인 관계다. 결국 리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다. 이는 “클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다”는 아주 중요한 결론을 이끈다.

```java
public class OverlappedDiscountPolicy extends DiscountPolicy {
	private List<DiscountPolicy> discountPolicy = new ArrayList<>();
	
	public OverlappedDiscountPolicy(DiscountPolicy... discountPolicy) {
		this.discountPolicy = Arrays.asList(discountPolicies);
	}

	@Override
	protected Money getDiscountAmount(Screening screening) {
		Money result = Money.ZERO;
		for(DiscountPolicy each : discountPolicies) {
			result = result.plus(each.calculateDiscountAmount(screening));		
		}
		return result;
	}
}
```

위 설계는 아래 세 가지 원칙이 어우러져 설계를 확장 가능하게 만든 대표적인 예다.

- **의존성 역전 원칙**

상위 수준 모듈인 Movie와 하위 수준 모듈인 OverlappedDiscountPolicy 모두 추상 클래스인 DiscountPolicy에 의존한다.

- **리스코프 치환 원칙**

DiscountPolicy와 협력하는 Movie 관점에서 DiscountPolicy 대신 OverlappedDiscountPolicy와 협력하더라도 아무런 문제가 없다.

- **개방-폐쇄 원칙**

중복 할인 정책이라는 새로운 기능을 추가하기 위해 DiscountPolicy의 자식 클래스인 OverlappedDiscountPolicy를 추가하더라도 Movie에는 영향을 미치지 않는다.

### 계약에 의한 설계와 서브타이핑

---

클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것을 게약에 의한 설계라고 부른다. 계약에 의한 설계는 세 가지 요소로 구성된다.

- **사전조건**: 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 조건
- **사후조건**: 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 조건
- **클래스 불변식**: 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 식

계약에 의한 설계를 사용하면 리스코프 치환 원칙이 강제하는 조건을 계약의 개념을 이용해 더 명확하게 설명할 수 있다.

Movie와 DiscountPolicy 사이의 계약에 대해 살펴보자

사전조건: calculateDiscountAmount 메서드는 클라이언트가 전달하는 screening의 값이 null이 아니고 영화 시작 시간이 아직 지나지 않았다고 가정하고 실행되기에 다음과 같이 표현 가능하다.

```java
assert screening != null && screening.getStartTime().isAfter(LocalDateTime.now());
```

사후조건: calculateDiscountAmount 메서드의 반환값은 항상 null이 아니어야 하고, 반환되는 값은 청구되는 요금이기 때문에 최소한 0원보다는 커야 한다.

```java
assert amount != null && amount.isGreaterThanOrEqual(Money.ZERO);
```

DiscountPolicy의 자식 클래스들이 Movie와 DiscoutPolicy 사이에 체결된 계약을 만족시키면 이 클래스들은 DiscountPolicy를 대체할 수 있기 때문에 서브타이핑 관계를 만족하게 된다.

- **************************************서브타입과 계약**************************************

만약 DiscountPolicy의 자식 클래스가 DiscountPolicy의 사전조건, 사후조건보다 더 강력하거나 약한 조건들로 제약하고 싶다면 어떻게 될까?

여기서 중요한 포인트는 Movie가 오직 DiscountPolicy의 조건만 알고 있다는 점이다. 따라서 Movie의 입장에서 DiscountPolicy의 사전조건보다 더 강력한 사전조건을 적용한 클래스와 협력하면 Movie의 입장에서 통과되어야 할 조건이 실패하기에 협력에 실패하게 된다. 반대로 약한 사전조건을 적용한 클래스와 협력하면 자신이 예상한 범주 내이기에 가능하다..?(책에서는 조건을 검사하지 않지만 이 클래스는 조건을 암묵적으로 지키고 있으니 괜찮다고 하는데 그런가..?)

Movie의 입장에서 DiscountPolicy의 사후조건보다 더 강력한 사전조건이 적용된 클래스와 협력하면 이미 자신이 제한한 조건을 만족하기에 괜찮다. 반대로 약한 사후조건을 적용하면 최소로 정해둔 기준에 미치지 못 하기에 협력에 실패한다.