---
marp: true
backgroundColor: #FFFFF0
theme: gaia
_class: lead
---

# 의존성 관리하기

### 최 혁

---

## 용어 정리

 **의존성: 두 객체 사이의 관계 유무**

 **결합도: 두 요소 사이에 존재하는 의존성의 정도**
 
 두 요소 사이에 존재하는 의존성이 바람직하다 = 결합도가 느슨하다 or 약하다

 두 요소 사이에 존재하는 의존성이 바람직하지 않다 = 결합도가 단단하다 or 강하다

    객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는 것

---

## 의존성

- 어떤 객체가 협력을 위해 다른 객체를 필요로 할 때 객체간의 의존성이 생긴다.
- 의존성은 방향을 가지며 항상 단방향이다.

__Movie ----> DiscountPolicy__

- Movie는 DiscountPolicy에 대해 의존성을 가진다.
- DiscountPolicy가 `변경`되면 Movie가 영향을 받는다. (역은 성립 x)

__다시 말해, 의존되는 요소가 변경되면 의존하는 요소의 변경이 일어날 수 있다!__
-> 따라서 `의존성`은 `변경에 의한 영향의 전파 가능성`을 암시한다.

---

##  의존성 전이

__의존성은 전이될 수 있다__

Screening --> Movie --> DiscountPolicy
(의존성 전이에 의해 Screnning이 DiscountPolicy에 의존한다)

의존성 = 변경될 수 있는 `가능성`(모든 경우에 의존성이 전이되는 것은 아니다)

의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.

- 직접 의존성: Screening --> Movie
- 간접 의존성: Screnning -->..--> DiscountPolicy

---

## 런타임 의존성 / 컴파일타임 의존성

- __런타임 의존성 -> 객체 사이의 의존성__
- __컴파일타임 의존성 -> 클래스 사이의 의존성__

        유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.

Movie --> DiscountPolicy(클래스)
Moview --> AmountDiscountPolicy(객체)

__클래스는 자신과 협력할 객체의 구체적인 클래스를 알면 알수록, 그 클래스가 사용되는 특정한 문맥에 강하게 결합된다.__
(특정한 문맥 = 특정한 하나의 협력)

---

## 컨텍스트 독립성

__클래스가 사용될 특정 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. -> 컨텍스트 독립성__

```java
class Movie {
    private DiscountPolicy discountPolicy;
    Movie(DiscountPolicy discoutPolicy) {
        1. this.discountPolicy = new AmountDiscountPolicy();
        2. this.discountPolicy = discountPolicy;
    }
}
```

---

## 의존성 해결 방법

1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
2. 객체 생성 후 setter 메서드를 통해 의존성 해결
3. 메서드 실행 시 인자를 이용해 의존성 해결

(setter만 사용시 null 위험)
(생성자 방식과 setter 방식을 혼합하는 것이 가장 선호되는 방법)
(일시적으로 의존하여 실행돼도 무방하다면 메서드 인자를 통해 의존성 해결?)

---

## 유연한 설계

__바람직한 의존성 = 다양한 환경의 재사용성__

__추상화에 의존하라!__
추상화를 사용하면 현재 문제를 해결하는데 불필요한 정보를 감출 수 있다. 
ㄴ> 대상을 알아야 할 지식의 양이 줄기에 결합도를 느슨하게 유지할 수 있다.

- 구체 클래스 의존성
- 추상 클래스 의존성
- 인터페이스 의존성

---

- __명시적인 의존성: 의존성을 생성자나 setter같은 퍼블릭 인터페이스에 노출__
- __숨겨진 의존성: 의존성이 퍼블릭 인터페이스에 노출되지 않고, 내부적으로 인스턴스를 생성__

=> 의존이 명시적이지 않으면 의존성 파악을 위해 내부 구현을 들여다봐야 할 뿐만 아니라, 재사용성에서 문제가 생긴다. 

__new는 해롭다__
new는 구체 클래스를 직접 의존해야 한다.
생성하기 위해 생성자 호출 시그니쳐와 사용할 값도 알아야 한다.

=> 해결 방법은 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것이다.(273p 예시 - Movie의 클라이언트가 처리한다.)

---

- 표준 클래스에 대한 의존은 해롭지 않다.

__유연하고 재사용 가능한 설계는 객체가 어떻게 하는지를 장황하게 나열하지 않고도 객체들의 조합을 통해 무엇을 하는지를 표현하는 클래스들로 구성된다. 따라서 클래스의 인스턴스를 생성하는 코드를 보는 것만으로 객체가 어떤 일을 하는지 쉽게 파악할 수 있다.__

